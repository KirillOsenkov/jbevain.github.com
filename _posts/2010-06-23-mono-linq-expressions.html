---
layout: post
title: Mono.Linq.Expressions
---
<a href="http://www.flickr.com/photos/jbevain/4165476445/" title="Statue by Jb Evain, on Flickr"><img src="http://farm3.static.flickr.com/2610/4165476445_cfe6112ce0.jpg" width="500" height="333" alt="Statue" style="border: 2px solid black" /></a>

In the same vein of my little <a href="http://github.com/jbevain/mono.reflection">Mono.Reflection</a> library, which complements the System.Reflection namespace with useful features such as an IL disassembler, <a href="http://github.com/jbevain/mono.linq.expressions">Mono.Linq.Expressions</a> is a small library for everyone who has to manipulate LINQ Expression Trees.

The first feature I've been adding is a simple pretty printer for expression trees. It comes in handy whenever you want a textual representation of an expression tree in a language you know.

For instance, let's imagine you're calling a method returning an expression:

<pre name="code" class="c-sharp:nocontrols:nogutter">
Expression<Func<int, int, int>> silly = GetSillyExpression ();
</pre>

And you want to quickly have a look at what it does. You may as well use a good old <i>Console.WriteLine</i>, but here's what it will print:

<pre>(a, b) => IIF((a > b), {var c; ... }, {var d; ... })</pre>

Yeah right. Not very useful isn't it. So let's use your internal knowledge of the DLR and print its DebugView:

<pre name="code" class="c-sharp:nocontrols:nogutter">
.Lambda #Lambda1<System.Func`3[System.Int32,System.Int32,System.Int32]>(
    System.Int32 $a,
    System.Int32 $b) {
    .If ($a > $b) {
        .Block(System.Int32 $c) {
            $c = $a #+ $b;
            $c #+= 42;
            $c
        }
    } .Else {
        .Block(System.Int32 $d) {
            $d = $a #- $b;
            $d #-= 42;
            $d
        }
    }
}
</pre>

Better yet. But it doesn't look even remotely familiar. Here comes <a href="http://github.com/jbevain/mono.linq.expressions">Mono.Linq.Expressions</a>.

Let's call <i>Console.WriteLine</i> once more, but in a slightly different way:

<pre name="code" class="c-sharp:nocontrols:nogutter">
Console.WriteLine (silly.ToCSharpCode ());
</pre>

And here's the output:

<pre name="code" class="c-sharp:nocontrols:nogutter">
int (int a, int b)
{
        if (a > b)
        {
                int c;

                c = checked { a + b };
                checked { c += 42 };
                return c;
        }
        else
        {
                int d;

                d = checked { a - b };
                checked { d -= 42 };
                return d;
        }
}
</pre>

Now I get it! And it's indeed plain silly. But that's not the point.

If you're implementing a language on top of the DLR, or playing with the new keyword dynamic's innards, or writing a LINQ provider, you might find it useful.
